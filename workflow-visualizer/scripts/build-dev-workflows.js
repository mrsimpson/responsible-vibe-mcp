#!/usr/bin/env node

/**
 * Script to generate BundledWorkflows.dev.ts from source workflow files
 * Dynamically discovers all YAML files for development mode
 */

import { writeFile, readdir, readFile } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import yaml from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const sourceDir = join(__dirname, '..', '..', 'resources', 'workflows');
const devBundledWorkflowsFile = join(
  __dirname,
  '..',
  'src',
  'services',
  'BundledWorkflows.dev.ts'
);

async function buildDevWorkflows() {
  try {
    console.log('üîÑ Building development workflow bundle...');
    console.log(`Source: ${sourceDir}`);

    // Read source directory and find all YAML files
    const files = await readdir(sourceDir);
    const yamlFiles = files.filter(
      file =>
        (file.endsWith('.yaml') || file.endsWith('.yml')) &&
        !file.startsWith('.') // Ignore hidden files
    );

    if (yamlFiles.length === 0) {
      console.warn('‚ö†Ô∏è  No YAML workflow files found in source directory');
      return;
    }

    console.log(`Found ${yamlFiles.length} workflow files:`);

    // Generate imports and entries for development (loads from source)
    const workflowImports = [];
    const workflowEntries = [];
    const workflowMetadata = [];

    for (const file of yamlFiles) {
      // Parse YAML to extract metadata
      const sourcePath = join(sourceDir, file);
      const content = await readFile(sourcePath, 'utf8');

      let metadata = null;
      try {
        const parsed = yaml.load(content);
        metadata = {
          name: parsed.name,
          description: parsed.description,
          domain: parsed.metadata?.domain,
          complexity: parsed.metadata?.complexity,
          bestFor: parsed.metadata?.bestFor,
          useCases: parsed.metadata?.useCases,
          examples: parsed.metadata?.examples,
        };
      } catch (error) {
        console.warn(
          `‚ö†Ô∏è  Failed to parse metadata for ${file}:`,
          error.message
        );
      }

      // Generate safe variable names (replace non-alphanumeric with underscore)
      const workflowName = file.replace(/\.(yaml|yml)$/, '');
      const safeVarName = workflowName.replace(/[^a-zA-Z0-9]/g, '_');
      const importName = `${safeVarName}Yaml`;

      workflowImports.push(
        `import ${importName} from '../../../resources/workflows/${file}?raw';`
      );
      workflowEntries.push(`  '${workflowName}': ${importName}`);
      workflowMetadata.push(
        `  '${workflowName}': ${JSON.stringify(metadata, null, 4).replace(/\n/g, '\n    ')}`
      );

      console.log(`  ‚úÖ ${file} -> ${workflowName}`);
    }

    // Generate BundledWorkflows.dev.ts for development
    const devBundledWorkflowsContent = `/**
 * Development version of bundled workflow definitions
 * Generated from source workflow files for development mode
 * DO NOT EDIT - This file is auto-generated by scripts/build-dev-workflows.js
 * 
 * Found ${yamlFiles.length} workflow files:
${yamlFiles.map(f => ` * - ${f}`).join('\n')}
 */

${workflowImports.join('\n')}

export const BUNDLED_WORKFLOWS: Record<string, string> = {
${workflowEntries.join(',\n')}
};

export const BUNDLED_WORKFLOW_METADATA: Record<string, any> = {
${workflowMetadata.join(',\n')}
};

export function getBundledWorkflow(name: string): string | null {
  return BUNDLED_WORKFLOWS[name] || null;
}

export function getBundledWorkflowMetadata(name: string): any | null {
  return BUNDLED_WORKFLOW_METADATA[name] || null;
}

export function getBundledWorkflowNames(): string[] {
  return Object.keys(BUNDLED_WORKFLOWS);
}
`;

    await writeFile(devBundledWorkflowsFile, devBundledWorkflowsContent);
    console.log(`üìù Generated ${devBundledWorkflowsFile}`);
    console.log(
      `üéâ Development workflow bundle complete! (${yamlFiles.length} workflows)`
    );
  } catch (error) {
    console.error('‚ùå Error building development workflows:', error.message);
    process.exit(1);
  }
}

buildDevWorkflows();
